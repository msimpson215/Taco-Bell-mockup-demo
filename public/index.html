<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>VoxTalk</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:,">
  <style>
    body {
      margin:0; font-family:system-ui,sans-serif;
      display:grid; place-items:center; min-height:100vh;
      background: radial-gradient(circle at 50% 20%, #dbeafe, #93c5fd 40%, #1e3a8a 90%);
    }
    h1 { margin:6px 0; font-size:22px; color:white; text-shadow:0 1px 3px #000; }
  </style>
</head>
<body>
  <h1>Talk to VoxTalk</h1>
  <audio id="remote" autoplay playsinline></audio>

  <script>
    const rtAudio = document.getElementById("remote");
    let dc, micSocket;

    async function initRealtime() {
      const s = await fetch("/session",{method:"POST"});
      const { client_secret, model, voice, language } = await s.json();

      const pc = new RTCPeerConnection();

      // ðŸ”Š Attach AI voice to <audio>
      pc.ontrack = (ev)=>{ rtAudio.srcObject = ev.streams[0]; };

      dc = pc.createDataChannel("events");

      const offer = await pc.createOffer({ offerToReceiveAudio:true });
      await pc.setLocalDescription(offer);

      const r = await fetch(
        `https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}&voice=${voice}&language=${language}`,
        {
          method:"POST",
          headers:{
            "Authorization":`Bearer ${client_secret.value}`,
            "Content-Type":"application/sdp"
          },
          body: offer.sdp
        }
      );
      const answer = {type:"answer", sdp: await r.text()};
      await pc.setRemoteDescription(answer);

      // ðŸ”’ Force English only
      dc.onopen = () => {
        dc.send(JSON.stringify({
          type:"session.update",
          session:{
            instructions:"Always respond ONLY in English. Refuse other languages.",
            voice, language:"en-US"
          }
        }));
      };

      // ðŸŽ¤ Connect to mic WebSocket â†’ Deepgram
      micSocket = new WebSocket(`wss://${window.location.host}`);
      micSocket.onmessage = (event) => {
        const { text } = JSON.parse(event.data);
        if (text) {
          // Send transcript â†’ AI Realtime
          dc.send(JSON.stringify({
            type:"response.create",
            response:{ instructions:text }
          }));
        }
      };

      // ðŸŽ™ Capture mic and stream PCM16
      const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
      const audioCtx = new AudioContext();
      const source = audioCtx.createMediaStreamSource(stream);
      const processor = audioCtx.createScriptProcessor(4096, 1, 1);
      source.connect(processor);
      processor.connect(audioCtx.destination);

      processor.onaudioprocess = (e) => {
        if (micSocket.readyState !== WebSocket.OPEN) return;
        const input = e.inputBuffer.getChannelData(0);
        const pcm16 = new Int16Array(input.length);
        for (let i=0; i<input.length; i++) {
          pcm16[i] = Math.max(-1, Math.min(1, input[i])) * 0x7fff;
        }
        micSocket.send(pcm16.buffer);
      };
    }

    // ðŸš€ Auto-start
    initRealtime();
  </script>
</body>
</html>
